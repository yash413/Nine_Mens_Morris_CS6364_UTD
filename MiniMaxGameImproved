p1 = 0


def static_estimation(b):
    global p1
    p1 += 1
    p2 = 0
    numWhitePieces = 0
    numBlackPieces = 0
    numWhiteMills = 0
    numBlackMills = 0
    numW2piece = 0 
    numB2piece = 0
    Whiteblockedpieces = 0
    Blackblockedpieces = 0
    for i in b:
        if i == "W":
            numWhitePieces += 1
        elif i == "B":
            numBlackPieces += 1
    for i in range(len(b)):
        if b[i] == 'W':
            if closeMill(i, b):
                numWhiteMills += 1
            if numWhitePieces > 3:
                n = neighbours(i)
                for j in n:
                    if b[j] == 'x':
                        break
                    else:
                        Whiteblockedpieces += 1
        elif b[i] == 'B':
            if closeMill(i, b):
                numBlackMills += 1
            if numBlackPieces > 3:
                n = neighbours(i)
                for j in n:
                    if b[j] == 'x':
                        break
                    else:
                        Blackblockedpieces += 1
        elif b[i] == 'x':
            b1 = b[:]
            b1[i] = 'W'
            if closeMill(i,b1):
                numW2piece += 1
            b1[i] = 'B'
            if closeMill(i,b1):
                numB2piece += 1
    numWhiteMills = int(numWhiteMills/3) + 1
    numBlackMills = int(numBlackMills/3) + 1
    if len(b) == 19:
        p2 = b[-1]
    if numBlackPieces <= 2:
        return 10000
    elif numWhitePieces <= 2:
        return -10000
    elif numBlackMoves(b) == 0:
        return 10000
    else:
        return (25 * (numWhiteMills - numBlackMills)) + (20 * p2) + (15 * (Whiteblockedpieces - Blackblockedpieces)) + (10 * (numW2piece- numB2piece)) + (5 * (numWhitePieces - numBlackPieces)) - numBlackMoves(b)


def numBlackMoves(l):
    ll = WtB(l)
    n = GenerateMovesMidgameEndgame(ll)
    if n <= 3:
        x = GenerateHopping(ll, 0)
    else:
        x = GenerateMove(ll, 0)
    return len(x)


def neighbours(j):
    def zero():
        return [1, 2, 15]

    def one():
        return [0, 3, 8]

    def two():
        return [0, 3, 4, 12]

    def three():
        return [1, 2, 5, 7]

    def four():
        return [2, 5, 9]

    def five():
        return [3, 4, 6]

    def six():
        return [5, 7, 11]

    def seven():
        return [3, 6, 8, 14]

    def eight():
        return [1, 7, 17]

    def nine():
        return [4, 10, 12]

    def ten():
        return [9, 11, 13]

    def eleven():
        return [6, 10, 14]

    def twelve():
        return [2, 9, 13, 15]

    def thirteen():
        return [10, 12, 14, 16]

    def fourteen():
        return [7, 11, 13, 17]

    def fifteen():
        return [0, 12, 16]

    def sixteen():
        return [13, 15, 17]

    def seventeen():
        return [8, 14, 16]

    switch = {0: zero, 1: one, 2: two, 3: three, 4: four, 5: five,
              6: six, 7: seven, 8: eight, 9: nine, 10: ten, 11: eleven,
              12: twelve, 13: thirteen, 14: fourteen, 15: fifteen, 16: sixteen, 17: seventeen}

    return switch[j]()


def closeMill(j, b):
    C = b[j]

    def zero():
        if b[2] == b[4] == C:
            return True
        else:
            return False

    def one():
        if (b[3] == b[5] == C) or (b[8] == b[17] == C):
            return True
        else:
            return False

    def two():
        if b[0] == b[4] == C:
            return True
        else:
            return False

    def three():
        if (b[1] == b[5] == C) or (b[7] == b[14] == C):
            return True
        else:
            return False

    def four():
        if b[0] == b[2] == C:
            return True
        else:
            return False

    def five():
        if (b[1] == b[3] == C) or (b[6] == b[11] == C):
            return True
        else:
            return False

    def six():
        if (b[5] == b[11] == C) or (b[7] == b[8] == C):
            return True
        else:
            return False

    def seven():
        if (b[6] == b[8] == C) or (b[3] == b[14] == C):
            return True
        else:
            return False

    def eight():
        if (b[6] == b[7] == C) or (b[1] == b[17] == C):
            return True
        else:
            return False

    def nine():
        if (b[10] == b[11] == C) or (b[12] == b[15] == C):
            return True
        else:
            return False

    def ten():
        if (b[9] == b[11] == C) or (b[13] == b[16] == C):
            return True
        else:
            return False

    def eleven():
        if (b[9] == b[10] == C) or (b[14] == b[17] == C):
            return True
        else:
            return False

    def twelve():
        if (b[9] == b[15] == C) or (b[13] == b[14] == C):
            return True
        else:
            return False

    def thirteen():
        if (b[12] == b[14] == C) or (b[10] == b[16] == C):
            return True
        else:
            return False

    def fourteen():
        if (b[12] == b[13] == C) or (b[11] == b[17] == C):
            return True
        else:
            return False

    def fifteen():
        if (b[16] == b[17] == C) or (b[12] == b[9] == C):
            return True
        else:
            return False

    def sixteen():
        if (b[15] == b[17] == C) or (b[13] == b[10] == C):
            return True
        else:
            return False

    def seventeen():
        if (b[15] == b[16] == C) or (b[14] == b[11] == C):
            return True
        else:
            return False

    switch = {0: zero, 1: one, 2: two, 3: three, 4: four, 5: five,
              6: six, 7: seven, 8: eight, 9: nine, 10: ten, 11: eleven,
              12: twelve, 13: thirteen, 14: fourteen, 15: fifteen, 16: sixteen, 17: seventeen}

    return switch[j]()


def generateRemove(b, L, p):
    for i in range(len(b)):
        if b[i] == "B":
            if not closeMill(i, b):
                b1 = b[:]
                b1[i] = 'x'
                if p == d:
                    if d % 2 == 0:
                        b1.append(int(-1))
                    else:
                        b1.append(int(1))
                L.append(b1)
            else:
                if p == d:
                    if d % 2 == 0:
                        b.append(int(-1))
                    else:
                        b.append(int(1))
                L.append(b)


def GenerateMove(b, ply):
    L = []
    for i in range(len(b)):
        if b[i] == "W":
            n = neighbours(i)
            for j in n:
                if b[j] == "x":
                    b1 = b[:]
                    b1[i] = "x"
                    b1[j] = "W"
                    if closeMill(j, b1):
                        generateRemove(b1, L, ply)
                    else:
                        L.append(b1)
    return L


def GenerateHopping(b, ply):
    L = []
    for i in range(len(b)):
        if b[i] == "W":
            for j in range(len(b)):
                if b[i] == "x":
                    b1 = b[:]
                    b1[i] = "x"
                    b1[j] = "W"
                    if closeMill(j, b1):
                        generateRemove(b1, L, ply)
                    else:
                        L.append(b1)
    return L


def GenerateMovesMidgameEndgame(b):
    n = 0
    for i in b:
        if i == "W":
            n += 1
    return n


def WtB(a):
    b = a[:]
    for i in range(len(b)):
        if b[i] == "W":
            b[i] = "B"
        elif b[i] == "B":
            b[i] = "W"
    return b


def MinMax(b, p):
    if p == d:
        return static_estimation(b)
    else:
        p += 1
        b = WtB(b)
        v = 10000
        n = GenerateMovesMidgameEndgame(b)
        if n == 3:
            x = GenerateHopping(b, p)
        else:
            x = GenerateMove(b, p)
        for i in x:
            i = WtB(i)
            v = min(v, MaxMin(i, p))
        return v


def MaxMin(a, ply):
    if ply == d:
        return static_estimation(a)
    else:
        ply += 1
        v = -10000
        n = GenerateMovesMidgameEndgame(a)
        if n <= 3:
            y = GenerateHopping(a, ply)
        else:
            y = GenerateMove(a, ply)
        for i in y:
            m = MinMax(i, ply)
            if m > v:
                x = i
                v = m
        if ply == 1:
            return x, v
        return v


(f1, f2, d) = list(input().split())
d = int(d)
file1 = open(f1)
l1 = list(file1.read())
(A1, A2) = MaxMin(l1, 0)
s = ""
for i in A1:
    s += i
file2 = open(f2, "w")
file2.write("Board position is: " + s + "\n\n" + "Positions evaluated by static estimation: " + str(p1) + "\n\n"
            + "MINIMAX estimate: " + str(A2))
